%\VignetteIndexEntry{SFSI-extdoc-SSI}
%\documentclass[article,shortnames,nojss]{jss}
\documentclass[11pt]{article}

\usepackage{amsmath}
\usepackage{enumerate}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage[most]{tcolorbox}
\usepackage{geometry}
\usepackage{blindtext}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[round]{natbib}
\hypersetup{colorlinks,
            citecolor=blue,
            filecolor=blue,
            linkcolor=blue,
            urlcolor=blue} %Necesario para facilitar lectura
 \geometry{
 a4paper,
 total={210mm,297mm},
 left=25mm,
 right=25mm,
 top=23mm,
 bottom=28mm,
 }

\newtcolorbox[auto counter]{mybox}[1][]{title={\bfseries Box~\thetcbcounter},enhanced,drop shadow={black!50!white},
  coltitle=black,
  top=0.1in,
  attach boxed title to top left=
  {xshift=1.3em,yshift=-\tcboxedtitleheight/2},
  boxed title style={size=small,colback=white},#1}

\begin{document}
\bibliographystyle{chicago}

\begin{table}[!htbp]
\begin{center}
\hrule
\vspace{5mm}
\begin{LARGE}
\textbf{Regularized selection indices for breeding value prediction using hyper-spectral image data} \\
\end{LARGE}
\vspace{8mm}
Marco Lopez-Cruz$^1$, Eric Olson$^1$, Gabriel Rovere$^{2,3,4}$, Jose Crossa$^6$, Susanne Dreisigacker$^6$,\\
Suchismita Mondal$^6$, Ravi Singh$^6$, and Gustavo de los Campos$^{3,4,5,}$* \\
\vspace{5mm}
\end{center}
\{$^1$Department of Plant, Soil and Microbial Sciences, $^2$Department of Animal Science,
$^3$Department of Epidemiology and Biostatistics, $^4$Institute for Quantitative Health Science and Engineering,
$^5$Department of Statistics and Probability\}, Michigan State University, USA \\
$^6$International Maize and Wheat Improvement Center (CIMMYT), Mexico \\
 \\
*Corresponding author (e-mail: \texttt{gustavoc@msu.edu}) \\
\hrule height 1mm 
\end{table}

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Selection index}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Recall the basic genetic model that decomposes phenotypic observations, $\boldsymbol{y}=(y_1,…,y_n)'$, as the sum of breeding values, $\boldsymbol{u}_y=(u_{y_1},…,u_{y_n})'$, and environmental deviations, $\boldsymbol{e}_y=(e_{y_1},…,e_{y_n})'$,  as 
\begin{equation}
\label{eqn:genmod}
y_i=u_{y_i}+e_{y_i}	
\end{equation}

Both $\boldsymbol{u}_y$ and $\boldsymbol{e}_y$ are assumed to have null means and $\text{var}(\boldsymbol{u}_y)=\sigma_{u_y}^2 \textbf{K}$, $\text{var}(\boldsymbol{e}_y)=\sigma_{e_y}^2 \textbf{I}$, and $\text{cov}(\boldsymbol{u},\boldsymbol{e}')=\textbf{0}$, where $\sigma_{u_y}^2$ and $\sigma_{e_y}^2$ are the common genetic and residual variances, respectively; $\textbf{K}$ is the \textbf{kinship relationship matrix} and $\textbf{I}$ is an identity matrix.

\vspace{5mm}

A \textbf{selection index} (SI) \citep{Hazel1943,Smith1936} is used to predict the genetic merit for a the selection goal ($u_{y_i}$, e.g., the genetic merit for grain yield of the $i^\text{th}$ genotype) as a linear combination of $p$ measured phenotypes, $\boldsymbol{x}_i=(x_{i1},...,x_{ip})'$, of the form
\begin{equation}
\label{eqn:predSI}
\mathcal{I}_i=\boldsymbol{x}'_i\boldsymbol{\beta}
\end{equation}
where $\boldsymbol{\beta}=(\beta_1,...,\beta_p)'$ is a vector of regression coefficients whose entries define the weights of each of the measured phenotypes in the SI. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Canonical selection index}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In a \textbf{canonical SI} (\textbf{CSI}) the weights are derived by minimizing the expected squared deviation between the genetic merit for the selection goal and the index, that is

\begin{equation*}
\hat{\boldsymbol{\beta}} = \underset{\beta}{\text{arg min}}\frac{1}{2}\mathbb{E}\left(u_{y_i}-\boldsymbol{x}'_i\boldsymbol{\beta}\right)^2
\end{equation*}

Assuming that $\boldsymbol{x}_i$ follows also model \eqref{eqn:genmod} and that their environmental effects ($\boldsymbol{e}_{x_i}$) are orthogonal to $u_{y_i}$, the above problem is equivalent to

\begin{equation}
\label{eqn:CSI}
\hat{\boldsymbol{\beta}} = \underset{\beta}{\text{arg min}}\left[-\textbf{G}'_{x,y}\boldsymbol{\beta} + \frac{1}{2}\boldsymbol{\beta}'\textbf{P}_x\boldsymbol{\beta}\right]
\end{equation}

where $\textbf{G}_{x,y}=\mathbb{E}(u_{y_i}\boldsymbol{x}_i)$ is a vector containing the genetic covariances between the selection target and each of the measured phenotypes, and $\textbf{P}_x=\mathbb{E}(\boldsymbol{x}_i\boldsymbol{x}'_i)$ is the phenotypic (co)variance matrix of $\boldsymbol{x}_i$. The solution to this optimization problem is
\begin{equation}
\label{eqn:betaCSI}
\hat{\boldsymbol{\beta}} = \textbf{P}_x^{-1} \textbf{G}_{x,y}
\end{equation}

The SI is by construction the \textbf{best linear predictor} (BLP) of the genetic merit for the selection goal; this property holds when $\textbf{G}_{x,y}$ and $\textbf{P}_x$ are known.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Regularized selection indices}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Principal components-based selection indices}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Principal components (PC) can be obtained from the singular value decomposition of the real-valued matrix, $\textbf{X}=[\boldsymbol{x}_1,\boldsymbol{x}_2,...,\boldsymbol{x}_n]'$ (the matrix containing all measured traits) which takes the form $\textbf{X}=\textbf{U}\textbf{D}\textbf{V}'$. Matrix $\textbf{U}=[\boldsymbol{u}_1,...,\boldsymbol{u}_p]$ contains the left-singular vectors, $\textbf{V}=[\boldsymbol{v}_1,...,\boldsymbol{v}_p]$ is the matrix with the right-singular vectors, and $\textbf{D}=\text{diag}(d_1,…,d_p)$ is a diagonal matrix with positive or zero elements. The PCs $\textbf{W}=\textbf{X}\textbf{V}=\textbf{U}\textbf{D}$ are then linear combinations of the measured phenotypes. A \textbf{principal components-based SI} (\textbf{PC-SI}) uses the first $q$ PCs ($\tilde{\textbf{W}}=[\boldsymbol{w}_1,...,\boldsymbol{w}_q]$, $q\leq p$) as 'measured phenotypes' in the SI, as

\begin{equation*}
\mathcal{I}_i=\tilde{\boldsymbol{w}}'_i\boldsymbol{\gamma}^{(q)}
\end{equation*}

where $\tilde{\boldsymbol{w}}'_i$ is a vector containing the scores for the $i^{th}$ observation on the first $q$ PCs and $\boldsymbol{\gamma}^{(q)}$ are their corresponding regression coefficients. The solution to the optimization problem takes the form $\hat{\boldsymbol{\gamma}}^{(q)}=(n-1)(\tilde{\textbf{D}}^2)^{-1}\textbf{G}_{\tilde{w},y}$, where $\tilde{\textbf{D}}$ contains only the first $q$ elements of $\textbf{D}$, and  $\textbf{G}_{\tilde{w},y}$ is a vector containing the genetic covariances between each of the top $q$ PCs and the selection objective. This solution can be mapped to coefficients for the measured traits, as in expression \eqref{eqn:predSI}, using

\begin{equation}
\label{eqn:betaPCSI}
\hat{\boldsymbol{\beta}}^{(q)}=(n-1)\tilde{\textbf{V}}(\tilde{\textbf{D}}^2)^{-1}\textbf{G}_{\tilde{w},y}
\end{equation}

where $\tilde{\boldsymbol{V}}$ is the matrix containing only the first $q$ right-singular vectors.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Penalized selection indices}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In a penalized regression, regularization is achieved by including in the objective function a penalty on model complexity. A \textbf{penalized selection index} (\textbf{PSI}) is obtained by considering an optimization problem as in \eqref{eqn:CSI}, as follows: 

\begin{equation}
\label{eqn:PSI}
\hat{\boldsymbol{\beta}} = \underset{\beta}{\text{arg min}}\left[-\textbf{G}'_{x,y}\boldsymbol{\beta} + \frac{1}{2}\boldsymbol{\beta}'\textbf{P}_x\boldsymbol{\beta} + \lambda\cdot J(\boldsymbol{\beta})\right]
\end{equation}

where $\lambda$ is a penalty parameter and $J(\boldsymbol{\beta}_i)$ is a penalty function. Commonly used penalties include the L2 ($||\boldsymbol{\beta}_i||^2_2=\sum_{j=1}^n\beta_{ij}^2$) and L1 ($||\boldsymbol{\beta}_i||_1=\sum_{j=1}^n|\beta_{ij}|$) norms \citep{Fu1998a} either alone or in a combination of both. We considered a penalty function as 
\begin{equation*}
J(\boldsymbol{\beta})=\frac{1}{2} (1-\alpha) \sum_{j=1}^n\beta_j^2 + \alpha \sum_{j=1}^n|\beta_j|
\end{equation*}
where $\alpha$ is a weighting factor. This penalty is used in an  \textbf{elastic-net-type} regression \citep{Zou2005} that combines the shrinkage-inducing feature of a \textbf{ridge-regression} \citep{Hoerl1970}, that uses the L2-norm alone, and the variable selection feature of a  \textbf{LASSO} regression \citep{Tibshirani1996}, that uses the L1-norm alone. With no penalization ($\lambda=0$), the solution for \eqref{eqn:PSI} is equivalent to that of the canonical SI in \eqref{eqn:betaCSI}.

\vspace{5mm}

The ridge-regression (\textbf{L2-PSI}) and LASSO (\textbf{L1-PSI}) types are special cases of the elastic-net-type PSI (\textbf{EN-PSI}) when $\alpha=0$ and $\alpha=1$, respectively. A closed-form solution for the regression coefficients can be found only for the L2-PSI \citep{Hastie2009a}. In this case, the solution is 
\begin{equation*}
\hat{\boldsymbol{\beta}}^{L2} = \left(\textbf{P}_x +\lambda \textbf{I}\right)^{-1} \textbf{G}_{x,y}
\end{equation*}
where $\textbf{I}$ is a $p\times p$ identity matrix. For the EN-PSI ($0<\alpha\leq1$) solutions are obtained using iterative algorithms such as \textbf{least angle regression} \citep{Efron2004} or \textbf{coordinate descent} \citep{Friedman2007} for different values of the parameters $\alpha$ and $\lambda$. These combinations of the values of $\alpha$  and $\lambda$  will result in different EN-PSI from which an optimal index can be obtained such as the prediction accuracy is maximum.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Phenotypic and genetic parameters}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The population phenotypic (co)variance matrix $\textbf{P}_x$ among the measured phenotypes is estimated using the unbiased sample (co)variance matrix given by 
\begin{equation*}
\hat{\textbf{P}}_x=\frac{1}{n-1}\sum_{i=1}^{n}\left(\boldsymbol{x}_i-\bar{\boldsymbol{x}}\right)\left(\boldsymbol{x}_i-\bar{\boldsymbol{x}}\right)'
\end{equation*}
where $\bar{\boldsymbol{x}}$ is the vector containing the sample mean of of the measured phenotypes. For centered data, this reduces to $\hat{\textbf{P}}_x=\frac{1}{n-1}\textbf{X}'\textbf{X}$, where $\textbf{X} = [\boldsymbol{x}_1,\boldsymbol{x}_2,...,\boldsymbol{x}_n]'$ is the matrix containing all measured traits.

\vspace{5mm}

The genetic covariance ($\textbf{G}_{y,x_j}$) between the target trait and the $j^\text{th}$ measured trait ($j=1,...,p$) is estimated using a sequence of uni-variate genetic models as in equation \eqref{eqn:genmod}. First, the model is fitted for the target trait as response, then for each of the measured traits, and then for the sum of the target trait and each of the measured traits. The genetic covariances between the target trait and the measured traits are then estimated using 
\begin{equation}
\label{eqn:gencov}
\hat{\textbf{G}}_{y,x_j}=\frac{1}{2}\left(\hat{\sigma}^2_{u_{y+xj}}-\hat{\sigma}^2_{u_y}-\hat{\sigma}^2_{u_{xj}}\right)
\end{equation}
where $\hat{\sigma}^2_{u_y}$, $\hat{\sigma}^2_{u_{xj}}$ and $\hat{\sigma}^2_{u_{y+xj}}$ are the estimated genetic variances for the target trait, the $j^\text{th}$ measured trait, and the sum of the target trait and the $j^\text{th}$ measured trait, respectively.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Accuracy of indirect selection}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The accuracy of the index to be used for indirect selection, $\text{Acc}(\mathcal{I})$, is defined as the correlation between the index ($\mathcal{I}_i$) and the breeding values ($u_i$). This parameter is equal to the product of the square root of the heritability of the SI, $h_\mathcal{I}$, times the genetic correlation between the SI and the selection target, $\text{cor}(u_{\mathcal{I}_i},u_{y_i})$, this is
\begin{equation*}
\text{Acc}(\mathcal{I})=\text{cor}(\mathcal{I}_i,u_i)=\text{cor}(u_{\mathcal{I}_i},u_{y_i})h_\mathcal{I}
\end{equation*}

The efficiency of indirect selection relative to mass phenotypic selection ($RE$) is calculated as the ratio between the accuracy of indirect selection and the accuracy of direct selection, $h_y$, this is 
\begin{equation*}
RE=\frac{h_\mathcal{I}}{h_y}\text{cor}(u_{\mathcal{I}_i},u_{y_i})
\end{equation*}

where $h_y$ is the square root of the heritability of the selection goal ($y$), calculated as
\begin{equation*}
h_y^2=\frac{\sigma^2_{u_y}}{\sigma^2_{u_y} +\sigma^2_{e_y}}
\end{equation*}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Cross validation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To avoid bias in the estimation, the accuracy of indirect selection must be estimated using data that was not used to derive the coefficients of the index. To this end, a \textbf{training-testing partition} procedure is implemented as follows: (i) data is partitioned into training (TRN) and testing (TST) sets, (ii) the coefficients of the SI, $\boldsymbol{\beta}$, are derived in the training set, (iii) these coefficients are applied to data of the testing set to derive an index (using \eqref{eqn:predSI}), and (iv) parameters $\text{cor}(u_{\mathcal{I}_i},u_{y_i})$, $h_\mathcal{I}$, and $\text{Acc}(\mathcal{I})$ are estimated in the testing set.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Experimental data}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The data set consists of 1,092 inbred wheat lines grouped into 39 trials and grown during the 2013-
2014 season at the Norman Borlaug experimental research station in Ciudad Obregon, Sonora,
Mexico. Each trial consisted of 28 breeding lines that were arranged in an alpha-lattice design with
three replicates and six sub-blocks. The trials were grown in four different environments:

\begin{itemize}
\item E1: \textit{Flat-Drought}. (1092 genotypes, 3274 records) Sowing in flat with irrigation of 180 mm through drip system
\item E2: \textit{Bed-2IR}. (1090 genotypes, 3267 records) Sowing in bed with 2 irrigations approximately 250 mm)
\item E3: \textit{Bed-5IR}. (1092 genotypes, 3274 records) Bed sowing with 5 normal irrigations
\item E4: \textit{Bed-EHeat}. (1013 genotypes, 2858 records) Bed sowing 30 days before optimal planting date with 5 normal irrigations of approximately 500 mm)
\end{itemize}
Records of grain yield (YLD) were collected as the total plot yield after maturity. Measurements for days to heading (DTH), days to maturity (DTM), and plant height (PH) were recorded only in the first replicate at each trial. Reflectance phenotypic data were
collected from the fields using both infrared (A600 series Infrared camera, FLIR, Wilsonville, OR) and hyper-spectral
(A-series, Micro-Hyperspec, VNIR Headwall
Photonics, Fitchburg, MA) cameras mounted on a Piper PA-16 Clipper aircraft on 9 different dates
(time-points) between January $10^\text{th}$ and March $27^\text{th}$, 2014. During each flight, data from 250 wavelengths
ranging from 392 to 850 nm were collected for each pixel in the pictures. The average
reflectance of all the pixels for each wavelength was calculated from each of the geo-referenced
trial plots and reported as each line reflectance.

\vspace{5mm}
Grain yield and image data were pre-adjusted using mixed-effects model that accounted for genotype, trial, replicate, and sub-block. No pre-adjusting was made for DTH, DTM, and PH traits. Pre-adjusted phenotypes were obtained by subtracting from the phenotypic record the mean plus BLUPs of trial, replicate, and sub-block effects.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The above described data will be used to generate selection indices for grain yield (as selection target) using all the wavelengths collected from cameras (measured phenotypes). Analyses will be implemented in \texttt{R} software using the \texttt{SFSI} R-package.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Data downloading}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Both phenotypic and reflectance data can be downloaded from from the \texttt{github} version of the \texttt{SFSI} R-package at \url{https://github.com/MarcooLopez/SFSI_data/tree/master/data}. Each \texttt{.RData} file corresponds to one environment and contains objects \texttt{Y}, \texttt{WL}, and \texttt{VI}. Matrix \texttt{Y} contains pre-adjusted observations for YLD, DTH, DTM, and PH. Object \texttt{WL} is a list type containing the hyper-spectral image data for all 9 time-points. Element \texttt{WL[[j]]},  $j=1,...9$, is a matrix with 250 columns (wavelengths) and rows matched with those of matrix \texttt{Y}. Likewise, the object \texttt{VI} is a list with 9 elements being two-columns matrices containing green and
red NDVI. \textbf{Box 1} below shows how to prepare data for a single environment which will be used in later analyses.

\vspace{5mm}

\begin{mybox}[title=\textbf{Box 1}. Data downloading]
\begin{footnotesize}
\begin{verbatim}
rm(list = ls())
setwd("/Users/epidemiology/Dropbox/MSU/PBGB/projects/PSI/pipeline")
site <-  "https://github.com/MarcooLopez/SFSI_data/blob/master/data" 
filename <- "wheat.E1.RData"

# Download files
dir.create("data", recursive=TRUE)
url <- paste0(site,"/",filename,"?raw=true")
download.file(url, destfile= paste0("./data/",filename), mode = "wb")
\end{verbatim}
\end{footnotesize}
\end{mybox}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Heritability and variance components}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Heritability can be calculated from variance components obtained by fitting the model \eqref{eqn:genmod} for the whole data. Code below illustrates how to fit this model using the \texttt{solveMixed} function from the \texttt{SFSI} R-package.

\vspace{5mm}

\begin{mybox}[title=\textbf{Box 2}. Variance components calculation]
\begin{footnotesize}
\begin{verbatim}
library(SFSI)

# Load data 
load(paste0("data/",filename))
Y$gid <- factor(as.character(Y$gid)) 
y <- as.vector(scale(Y[,"YLD"]))

# Fit model
Z <- model.matrix(~0+gid,data=Y)
evdKtK <- eigen(tcrossprod(K))
fm0 <- solveMixed(y,U=evdKtK$vectors,d=evdKtK$values,BLUP=FALSE) 
c(fm0$varU,fm0$varE,fm0$h2)

dir.create("output", recursive=TRUE)
save(fm0,evdKtK,file="output/varComps.RData")
\end{verbatim}
\end{footnotesize}
\end{mybox}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Training-testing partitions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Code in \textbf{Box 3} below illustrates how to split data into TRN and TST sets. In this example, $\frac{2}{3}$ of the 29 trials (26 trials, $n_{TRN}\approx 2,184$ observations) will be randomly assigned to the training set and the remaining $\frac{1}{3}$ (13 trials, $n_{TST}\approx 1,092$) to the testing set.
\vspace{5mm}

The output will be a 'list' type of length \texttt{nPart} containing indices indicating which observations are assigned to testing sets. The object will be saved in the file \texttt{partitions.RData} and will be used later for single time-point and across time-points analyses.

\vspace{5mm}

\begin{mybox}[title=\textbf{Box 3}. Create testing set partitions]
\begin{footnotesize}
\begin{verbatim}
trials <- as.numeric(as.character(Y$trial))
nTrial <- length(unique(trials))
nTST <- ceiling((1/3)*nTrial)  # Number of trials in TST set

nPart <- 5     # Number of partitions
seeds <- round(seq(1E3, .Machine$integer.max, length = nPart))

partitions <- vector("list",length=nPart)   # Object to store partitions

for(k in 1:length(partitions))
{   set.seed(seeds[k])
    tst <- sample(1:nTrial,nTST,replace=FALSE)
    partitions[[k]] <- which(trials %in% tst)
}
save(partitions,file="output/partitions.RData")
\end{verbatim}
\end{footnotesize}
\end{mybox}

\vspace{12mm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Genetic covariances estimation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The genetic covariances between the grain yield and each of the wavelengths will be calculated using a sequence of models as described in \eqref{eqn:gencov} implemented in the \texttt{getGenCov} function from the \texttt{SFSI} package. Code in \textbf{Box 4} below shows how to calculate genetic and phenotypic covariances within time-point. The time-point can be specified through variable \texttt{tp} thus it can be changed to calculate covariances for all the 9 time-points. Calculations are performed using data from training set only for each partition. Results are stored in matrices \texttt{gencov} and \texttt{phencov}, and saved in the file \texttt{covariances.RData}.

\vspace{5mm}

\begin{mybox}[title=\textbf{Box 4}. Genetic covariances within time-point]
\begin{footnotesize}
\begin{verbatim}
tp <- 9      # Time-point
load("output/partitions.RData")

gencov <- phencov <- c()   # Matrices to store covariances

for(k in 1:length(partitions))
{   cat("  partition = ",k,"of",length(partitions),"\n")
    indexTST <- partitions[[k]]
    indexTRN <- (1:nrow(Y))[-indexTST]
    
    # Training set
    xTRN <- scale(WL[[tp]][indexTRN,])
    yTRN <- as.vector(scale(Y[indexTRN,"YLD"]))
 
    genotype <- factor(as.character(Y[indexTRN,"gid"])) 
    Z <- model.matrix(~ 0 + genotype)   # Design matrix for genotypes
    ZZt <- tcrossprod(Z) 
        
    # Get genetic variances and covariances
    fm <- getGenCov(y1=yTRN,y2=xTRN,K=ZZt,mc.cores=5,scale=FALSE)
    
    gencov <- cbind(gencov,fm$covU)
    phencov <- cbind(phencov,fm$covU + fm$covE)
}
dir.create(paste0("output/timepoint_",tp), recursive=TRUE)
save(gencov,phencov,file=paste0("output/timepoint_",tp,"/covariances.RData"))
\end{verbatim}
\end{footnotesize}
\end{mybox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Single time-point selection indices}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Canonical, L1-penalized and PC-based SIs will be fitted using data from a single time-point. The regression coefficients are to be obtained from training data within each partition previously created.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Regression coefficients}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Code in \textbf{Box 5a} can be used to estimate regression coefficients using training data within each partition following equations \eqref{eqn:betaCSI} (for the CSI), and \eqref{eqn:betaPCSI} (with different number of PCs for the PC-SI). Coefficients for L1-PSI are estimated as in expression \eqref{eqn:PSI} whose solutions are found using the \texttt{solveEN} function from the \texttt{SFSI} R-package. This function  implements the coordinate descent algorithm for different values of parameter $\lambda$. 

\vspace{5mm}

Time-point can be specified through variable \texttt{tp} thus it can be changed to get results for all time-points ($1, 2,...,9$). Results are stored in matrices \texttt{betaCSI}, \texttt{betaPCSI} and \texttt{betaL1PSI}, and saved in the file \texttt{coefficients.RData}. Calculations are performed across all partitions previously created.

\begin{mybox}[title=\textbf{Box 5a}. Regression coefficients within time-point]
\begin{footnotesize}
\begin{verbatim}
tp <- 9      # Time-point
load(paste0("output/timepoint_",tp,"/covariances.RData"))
load("output/partitions.RData")

# Objects to store regression coefficients
betaCSI <- betaPCSI <- betaL1PSI <- vector("list",length(partitions))

for(k in 1:length(partitions))
{   cat("  partition = ",k,"of",length(partitions),"\n")
    indexTST <- partitions[[k]]
    indexTRN <- (1:nrow(Y))[-indexTST]
    
    # Training set
    xTRN <- scale(WL[[tp]][indexTRN,])
    VARx <- var(xTRN)
    EVDx <- eigen(VARx)
    
    # -- Canonical SI --
    VARinv <- EVDx$vectors %*% diag(1/EVDx$values) %*% t(EVDx$vectors)
    betaCSI[[k]] <- VARinv %*%  gencov[,k]
    
    # -- PC-SI --
    VARinv <- diag(1/EVDx$values)
    gamma <- as.vector(VARinv %*% t(EVDx$vectors) %*%  gencov[,k])
    beta <- apply(EVDx$vectors %*% diag(gamma),1,cumsum)
    betaPCSI[[k]] <- data.frame(I(beta),df=1:nrow(beta),lambda=NA)
    
    # -- L1-PSI --
    fm <- solveEN(VARx, gencov[,k])
    beta <- as.matrix(fm$beta)[-1,]
    betaL1PSI[[k]] <- data.frame(I(beta),df=fm$df[-1],lambda=fm$lambda[-1])
}
save(betaCSI,betaPCSI,betaL1PSI,file=paste0("output/timepoint_",tp,"/coefficients.RData"))
\end{verbatim}
\end{footnotesize}
\end{mybox}

\vspace{5mm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Accuracy of the index}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The regression coefficients above calculated can be applied to data from testing set to derive selection indices (as in equation \eqref{eqn:predSI}). Code in \textbf{Box 5b} can be used to (i) compute the SIs for the testing data, and then (ii) calculate the accuracy of the index, the heritability of the index, and genetic correlation of the index with grain yield. The genetic covariances are obtained using again the approach in \eqref{eqn:gencov} implemented in the \texttt{getGenCov} function. 

\vspace{5mm}

Results for the three indices (CSI, PC-SI and L1-PSI) are stored in the object matrix \texttt{accSI} and saved in the file \texttt{accuracies.RData}. Calculations are performed across all partitions previously created.

\vspace{5mm}

\begin{mybox}[title=\textbf{Box 5b}. Accuracy of selection within time-point]
\begin{footnotesize}
\begin{verbatim}
tp <- 9      # Time-point
load(paste0("output/timepoint_",tp,"/coefficients.RData"))
load("output/partitions.RData")

accSI <- c()    # Object to store accuracy components

for(k in 1:length(partitions))
{   cat("  partition = ",k,"of",length(partitions),"\n")
    indexTST <- partitions[[k]]
    
    # Testing set
    xTST <- scale(WL[[tp]][indexTST,])
    yTST <- as.vector(scale(Y[indexTST,"YLD"]))
    genotype <- factor(as.character(Y[indexTST,"gid"])) 
    Z <- model.matrix(~ 0 + genotype)    # Design matrix for genotypes
        
    # Calculate the indices
    CSI <- xTST %*% betaCSI[[k]]
    PCSI <- tcrossprod(xTST, betaPCSI[[k]]$beta)
    L1PSI <- tcrossprod(xTST, betaL1PSI[[k]]$beta)
    
    # Fit genetic models   
    ZZt <- tcrossprod(Z)
    SI <- as.matrix(data.frame(I(CSI),I(PCSI),I(L1PSI)))
    fm <- getGenCov(y1=yTST,y2=SI,K=ZZt)
    
    # Retrieve accuracy components
    h <- sqrt(fm$varU2/(fm$varU2 + fm$varE2))
    gencor <- fm$covU/sqrt(fm$varU1*fm$varU2)
    accuracy <- gencor*h
    
    df <- c(max(betaL1PSI[[k]]$df),betaPCSI[[k]]$df,betaL1PSI[[k]]$df)
    lambda <- c(min(betaL1PSI[[k]]$lambda),betaPCSI[[k]]$lambda,betaL1PSI[[k]]$lambda)
    accSI <- rbind(accSI,data.frame(rep=k,SI=colnames(SI),h,gencor,accuracy,df,lambda))
}
save(accSI,file=paste0("output/timepoint_",tp,"/accuracies.RData"))
\end{verbatim}
\end{footnotesize}
\end{mybox}

\vspace{5mm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Effect of regularization on the accuracy of the index}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The regularized selection indices were calculated for $q=1,2,...,250$ PCs for the PC-SI and for decreasing values, $\lambda_1,...,\lambda_{100}$, of the penalization for the L1-PSI. In the later case, decreasing $\lambda$ will give increasing number of active number of predictors in the index. Code in \textbf{Box 6} below can be used to create a plot depicting the evolution of accuracy (and its components) over values of regularization (number of PCs or number of active predictors). Results for the CSI corresponds to the case of a PC-SI with 250 PCs and a L1-PSI with 250 active predictors. These cases are shown at the right-most results in the plots.

\vspace{5mm}

\begin{mybox}[title=\textbf{Box 6}. Effect of regularization]
\begin{footnotesize}
\begin{verbatim}
library(ggplot2); library(reshape); library(ggpubr)

tp <- 9      # Time-point
load(paste0("output/timepoint_",tp,"/accuracies.RData"))

accSI <- split(accSI,as.character(accSI$SI))
accSI <- data.frame(do.call(rbind,lapply(accSI,function(x)apply(x[,-c(1,2)],2,mean))))
accSI$SI <- unlist(lapply(strsplit(rownames(accSI),"\\."),function(x)x[1]))

# Plot of PC-SI
dat <- melt(accSI[accSI$SI=="PCSI",],id=c("df","lambda","SI"))
plot1 <- ggplot(dat[dat$df>1,],aes(df,value,group=variable,color=variable)) + theme_bw() +
  geom_line(size=1) + labs(title="PC-SI",y="correlation",x="Number of PCs")
  
# Plot of L1-PSI
dat <- melt(accSI[accSI$SI=="L1PSI",],id=c("df","lambda","SI"))
plot2 <- ggplot(dat[dat$df>1,],aes(df,value,group=variable,color=variable)) + theme_bw() +
  geom_line(size=1) + labs(title="L1-PSI",y="correlation",x="Number of active predictors")

ggarrange(plot1,plot2,nrow=1,common.legend=TRUE,legend="right")
\end{verbatim}
\end{footnotesize}
\end{mybox}

\vspace{5mm}

\begin{figure}[htb]
  \centering
  \includegraphics[width=0.99\textwidth]{FigureSSI_1}
  \caption{\small{Accuracy of selection (average across 10 TRN-TST partitions) and its components of the index versus the number of principal components entering in the PC-SI (left) and the number of active predictors in the L1-PSI (right). Timepoint 9. Environment E1}}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Optimal regularized vs canonical selection indices}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

An optimal regularized selection index can be chosen by selecting an optimal regularization (number of PCs or value of $\lambda$) such that the accuracy of selection of the resulting index in the testing set is maximum. Code in \textbf{Box 7} below can be used to select the optimal PC-SI and L1-PSI, and to compare the accuracy of selection with that of the CSI (non-regularized). Results are reported as an average across all partitions along with a $95\%$ confidence interval. 

\vspace{5mm}

\begin{mybox}[title=\textbf{Box 7}. Optimal selection index]
\begin{footnotesize}
\begin{verbatim}
tp <- 9      # Time-point
load(paste0("output/timepoint_",tp,"/accuracies.RData"))

accSI$SI <- unlist(lapply(strsplit(as.character(accSI$SI),"\\."),function(x)x[1]))
accSI <- split(accSI,paste(accSI$rep,"_",accSI$SI))
accSI <- do.call(rbind,lapply(accSI,function(x)x[which.max(x$accuracy),]))

dat = aggregate(accuracy ~ SI, mean, data=accSI)
dat$sd = aggregate(accuracy ~ SI,sd,data=accSI)$accuracy
dat$n = aggregate(accuracy ~ SI,length,data=accSI)$accuracy
dat$se = qnorm(0.975)*dat$sd/sqrt(dat$n)

ggplot(dat,aes(SI,accuracy,ymin=accuracy-se,ymax=accuracy+se)) + theme_bw() +
   geom_bar(stat="identity",width=0.5,fill="orange") + geom_errorbar(width=0.2) +
   geom_text(aes(label=sprintf("%.3f",accuracy)),y=min(dat$accuracy)*0.75)+labs(x="")
\end{verbatim}
\end{footnotesize}
\end{mybox}

\begin{figure}[htb]
  \centering
  \includegraphics[width=0.6\textwidth]{FigureSSI_2}
  \caption{\small{Accuracy of selection (average across 10 TRN-TST partitions) of the CSI, and the optimal PC-SI and L1-PSI. Timepoint 9. Environment E1}}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Comparison of the indices across time-points}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The accuracy of indirect selection for the optimal (i.e., the one with the highest accuracy of indirect selection) L1-PSI and PC-SI can be assessed across time-points and compared with a canonical SI. Code in \textbf{Box 8} below can be used to calculate the optimal PC-SI and L1-PSI, and to compare their accuracy of selection with that of the CSI across all time-points. 

\vspace{5mm}
To this end, all the within time-point analyses in \textbf{Box 4b}, \textbf{Box 5a} and \textbf{Box 5b} must be previously performed for all the 9 time-points. This can be achieved using, for instance, a loop as: \texttt{for(tp in 1:9)\{  \}}.

\vspace{5mm}

\begin{mybox}[title=\textbf{Box 8}. Accuracy across time-points]
\begin{footnotesize}
\begin{verbatim}
AccSI <- c()
for(tp in 1:9)
{ load(paste0("output/timepoint_",tp,"/accuracies.RData"))
  AccSI <- rbind(AccSI,data.frame(Timepoint=tp,accSI))
}

AccSI$SI <- unlist(lapply(strsplit(as.character(AccSI$SI),"\\."),function(x)x[1]))
AccSI <- split(AccSI,paste(AccSI$Timepoint,"_",AccSI$rep,"_",AccSI$SI))
AccSI <- do.call(rbind,lapply(AccSI,function(x)x[which.max(x$accuracy),]))
AccSI$Timepoint <- factor(as.character(AccSI$Timepoint))

dat = aggregate(accuracy ~ SI + Timepoint,mean,data=AccSI)
dat$sd = aggregate(accuracy ~ SI + Timepoint,sd,data=AccSI)$accuracy
dat$n = aggregate(accuracy ~ SI + Timepoint,length,data=AccSI)$accuracy
dat$se = qnorm(0.975)*dat$sd/sqrt(dat$n)

ggplot(dat,aes(Timepoint,accuracy,color=SI,group=SI,ymin=accuracy-se,ymax=accuracy+se))+  
   geom_line() + geom_point() + theme_bw() + geom_errorbar(width=0.2) 
\end{verbatim}
\end{footnotesize}
\end{mybox}

\begin{figure}[htb]
  \centering
  \includegraphics[width=0.8\textwidth]{FigureSSI_3}
  \caption{\small{Accuracy of selection (average across 10 TRN-TST partitions) of the CSI, and the optimal PC-SI and L1-PSI. Timepoint 9. Environment E1}}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Multi time-point selection indices}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Selection indices can be calculated to include reflectance data from multiple time-points. In this case, the vector of measured phenotypes $\boldsymbol{x}_i$ will contain $2,250$ traits corresponding to 250 wavebands measured at each of 9 time-points.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Regression coefficients}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Code in \textbf{Box 9a} shows how to calculate coefficients for the PC-SI and L1-PSI using data from all 9 time-points. To this end, the genetic covariances of all $2,250$ traits with grain yield are needed, thus, all the within time-point genetic covariances must be previously calculated for all the 9 time-points using code in \textbf{Box 4b}.  Results are saved in file \texttt{coefficients.RData} in folder \texttt{output/multi\_timepoint}.

\vspace{5mm}

\begin{mybox}[title=\textbf{Box 9a}. Regression coefficients multi time-points]
\begin{footnotesize}
\begin{verbatim}
Gencov <- c()
for(tp in 1:9)
{ load(paste0("output/timepoint_",tp,"/covariances.RData"))
  Gencov <- rbind(Gencov,gencov)
}
load("output/partitions.RData")

# Objects to store regression coefficients
betaPCSI <- betaL1PSI <- vector("list",length(partitions))

for(k in 1:length(partitions))
{   cat("  partition = ",k,"of",length(partitions),"\n")
    indexTST <- partitions[[k]]
    indexTRN <- (1:nrow(Y))[-indexTST]
    
    # Training set
    xTRN <- scale(do.call(cbind,WL)[indexTRN,])
    VARx <- var(xTRN)
    EVDx <- eigen(VARx)
    
    # -- PC-SI --
    gamma <- t(sweep(EVDx$vectors,2,1/EVDx$values,FUN="*")) %*%  Gencov[,k]
    beta <- apply(sweep(EVDx$vectors,2,as.vector(gamma),FUN="*"),1,cumsum)[1:500,]
    betaPCSI[[k]] <- data.frame(I(beta),df=1:nrow(beta),lambda=NA)
    
    # -- L1-PSI --
    fm <- solveEN(VARx, Gencov[,k],nLambda=100,maxIter=200,tol=5E-4)
    beta <- as.matrix(fm$beta)[-1,]
    betaL1PSI[[k]] <- data.frame(I(beta),df=fm$df[-1],lambda=fm$lambda[-1])
}
dir.create("output/multi_timepoint", recursive=TRUE)
save(betaPCSI,betaL1PSI,file="output/multi_timepoint/coefficients.RData")
\end{verbatim}
\end{footnotesize}
\end{mybox}

\vspace{5mm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Accuracy of the index}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

As for the single time-point, the regression coefficients are applied to data from testing set to derive selection indices. Code in \textbf{Box 9b} can be used to (i) compute the multi time-point PC-SI and L1-PSI for the testing data, and then (ii) calculate the accuracy of the index, the heritability of the index, and genetic correlation of the index with grain yield. The genetic covariances are obtained using the \texttt{getGenCov} function. 

\vspace{5mm}

Results for the two indices (PC-SI and L1-PSI) are stored in the object matrix \texttt{AccSI} and saved in the file \texttt{accuracies.RData} in  folder \texttt{output/multi\_timepoint}. Calculations are performed across all partitions previously created.

\begin{mybox}[title=\textbf{Box 9b}. Accuracy of selection multi time-points]
\begin{footnotesize}
\begin{verbatim}
load("output/partitions.RData")
load("output/multi_timepoint/coefficients.RData")

AccSI <- c()     # Objects to store accuracy components

for(k in 1:length(partitions))
{   cat("  partition = ",k,"of",length(partitions),"\n")
    indexTST <- partitions[[k]]
    
    # Testing set
    xTST <- scale(do.call(cbind,WL)[indexTST,])
    yTST <- as.vector(scale(Y[indexTST,"YLD"]))
    genotype <- factor(as.character(Y[indexTST,"gid"])) 
    Z <- model.matrix(~ 0 + genotype)
        
    # Calculate the indices
    PCSI_multi <- tcrossprod(xTST, betaPCSI[[k]]$beta)
    L1PSI_multi <- tcrossprod(xTST, betaL1PSI[[k]]$beta)
    
    # Fit genetic models
    ZZt <- tcrossprod(Z)
    SI <- as.matrix(data.frame(I(PCSI_multi),I(L1PSI_multi)))
    fm <- getGenCov(y1=yTST,y2=SI,K=ZZt)
   
    # Retrieve accuracy components
    h <- sqrt(fm$varU2/(fm$varU2 + fm$varE2))
    gencor <- fm$covU/sqrt(fm$varU1*fm$varU2)
    accuracy <- gencor*h
    
    df <- c(betaPCSI[[k]]$df,betaL1PSI[[k]]$df)
    lambda <- c(betaPCSI[[k]]$lambda,betaL1PSI[[k]]$lambda)
    AccSI <- rbind(AccSI,data.frame(rep=k,SI=colnames(SI),h,gencor,accuracy,df,lambda))
}
save(AccSI,file="output/multi_timepoint/accuracies.RData")
\end{verbatim}
\end{footnotesize}
\end{mybox}

\vspace{5mm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Optimal multi vs single time-point selection indices}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

As for the single time-point case, one can obtain an optimal regularized selection index such that the accuracy of selection in the testing set is maximum. Code in \textbf{Box 10} below can be used to select the optimal PC-SI and L1-PSI, and to compare the accuracy of selection with that of the single time-point CSI, PC-SI and L1-PSI. Results are reported as an average across all partitions along with a $95\%$ confidence interval.

\begin{mybox}[title=\textbf{Box 10}. Optimal selection index]
\begin{footnotesize}
\begin{verbatim}
tp <- 9      # Time-point
load(paste0("output/timepoint_",tp,"/accuracies.RData"))
load("output/multi_timepoint/accuracies.RData")

AccSI <- rbind(accSI,AccSI)

AccSI$SI <- unlist(lapply(strsplit(as.character(AccSI$SI),"\\."),function(x)x[1]))
AccSI <- split(AccSI,paste(AccSI$rep,"_",AccSI$SI))
AccSI <- do.call(rbind,lapply(AccSI,function(x)x[which.max(x$accuracy),]))

dat = aggregate(accuracy ~ SI, mean,data=AccSI)
dat$sd = aggregate(accuracy ~ SI, sd, data=AccSI)$accuracy
dat$n = aggregate(accuracy ~ SI, length, data=AccSI)$accuracy
dat$se = qnorm(0.975)*dat$sd/sqrt(dat$n)

ggplot(dat,aes(SI,accuracy,ymin=accuracy-se,ymax=accuracy+se)) + theme_bw() +
   geom_bar(stat="identity",width=0.65,fill="orange") + geom_errorbar(width=0.2) + 
   geom_text(aes(label=sprintf("%.3f",accuracy)),y=min(dat$accuracy)*0.75)+labs(x="")
\end{verbatim}
\end{footnotesize}
\end{mybox}

\begin{figure}[htb]
  \centering
  \includegraphics[width=0.65\textwidth]{FigureSSI_4}
  \caption{\small{Accuracy of selection (average across 10 TRN-TST partitions) of the CSI, and the optimal PC-SI and L1-PSI for the time-point 9 and multi time-point. Environment E1}}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Sparsity of the index}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The value of $\lambda$ in \eqref{eqn:PSI} for the L1-PSI define the number of predictors with non-zero coefficient in the index. Code in \textbf{Box 11} below can be used to estimate the regression coefficients for a multi time-point L1-PSI for the whole dataset. To achieve this, the genetic covariances will be calculated for the $2,250$ wavelengths using whole data by means of the \texttt{getGenCov} function. The coefficients are then obtained using the \texttt{solveEN} with a value of $\lambda$ obtained from the partitions.

\vspace{5mm}
A heatmap of the coefficients will be generated to show the sparsity and regions of the electromagnetic spectrum that were selected by the method.
\vspace{5mm}

\begin{mybox}[title=\textbf{Box 11}. Sparsity of the optimal index]
\begin{footnotesize}
\begin{verbatim}
load("output/varComps.RData")
load("output/multi_timepoint/accuracies.RData")

# Get genetic covariances
x <- scale(do.call(cbind,WL))
fm <- getGenCov(y1=Y$YLD,y2=x,U=evdKtK$vectors,d=evdKtK$values, mc.cores=5)
gencov <- fm$covU

# Get a value of lambda across partitions
AccSI$SI <- unlist(lapply(strsplit(as.character(AccSI$SI),"\\."),function(x)x[1]))
AccSI <- split(AccSI,paste0(AccSI$SI,"_",AccSI$rep))
AccSI <- do.call(rbind,lapply(AccSI,function(x)x[which.max(x$accuracy),]))
lambda <- mean(AccSI$lambda[AccSI$SI=="L1PSI_multi"])

# Get regression coefficients   
VARx <- var(x)
beta <- solveEN(VARx,gencov,lambda=lambda)$beta

wl <- factor(rep(gsub("wl","",colnames(WL[[1]])),9))
Timepoint <- factor(rep(1:9,each=ncol(WL[[1]])))
dat <- data.frame(beta=as.vector(beta),Timepoint,wl)
dat$beta[abs(dat$beta) < .Machine$double.eps] <- NA

ggplot(dat, aes(x=wl,y=Timepoint,fill = abs(beta))) + geom_tile(height=0.8) + 
  theme_bw() + labs(x="Wavelength (nm)") +
  scale_x_discrete(breaks = levels(wl)[seq(1,nlevels(wl),25)]) + 
  scale_fill_gradientn(na.value = 'gray35', colours = c(rev(heat.colors(15))))
\end{verbatim}
\end{footnotesize}
\end{mybox}
\begin{figure}[h]
  \centering
  \includegraphics[width=0.89\textwidth]{FigureSSI_5}
  \caption{\small{Heatmap of regression coefficients for L1-penalized SI using multi time-point data}}
\end{figure}

\vspace{5mm}
%At the end, the bibliography
\bibliography{references.bib}

\end{document}




