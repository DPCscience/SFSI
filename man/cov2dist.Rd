% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/R_utils_wC.R
\name{cov2dist}
\alias{cov2dist}
\title{cov2dist function}
\usage{
cov2dist(XtX, void = FALSE)
}
\arguments{
\item{XtX}{Symmetric variance-covariance matrix among \eqn{p}{p} (centered) variables}

\item{void}{\code{TRUE} or \code{FALSE} to whether return or not return the output.
When \code{FALSE} no result is displayed but the input \code{XtX} is modified. Default \code{void=FALSE}}
}
\value{
A matrix \eqn{D} containing the squared Euclidean distances
}
\description{
Computes a squared Euclidean distance matrix from a covariance matrix among \eqn{p}{p} variables with mean zero
}
\details{
For any variables
\ifelse{html}{\out{X<sub>i</sub>}}{\eqn{X_i}{X_i}} and
\ifelse{html}{\out{X<sub>j</sub>}}{\eqn{X_j}{X_j}} with mean zero and with sample vectors
\ifelse{html}{\out{<b>x</b><sub>i</sub> = (x<sub>i1</sub>,...,x<sub>in</sub>)'}}{\eqn{\textbf{x}_i=(x_{i1},...,x_{in})'}{x_i=(x_i1,...,x_in)'}} and
\ifelse{html}{\out{<b>x</b><sub>j</sub> = (x<sub>j1</sub>,...,x<sub>jn</sub>)'}}{\eqn{\textbf{x}_j=(x_{j1},...,x_{jn})'}{x_j=(x_j1,...,x_jn)'}}
, their (sample) variances are equal (up-to a constant) to their cross-products, this is,
\ifelse{html}{\out{var(X<sub>i</sub>) = <b>x</b>'<sub>i</sub><b>x</b><sub>i</sub>}}{\eqn{var(X_i)=\textbf{x}_i'\textbf{x}_i}{var(X_i) = x'_i x_i}} and
\ifelse{html}{\out{var(X<sub>j</sub>) = <b>x</b>'<sub>j</sub><b>x</b><sub>j</sub>}}{\eqn{var(X_j)=\textbf{x}_j'\textbf{x}_j}{var(X_j) = x'_j x_j}}.
Likewise, the covariance is
\ifelse{html}{\out{cov(X<sub>i</sub>,X<sub>j</sub>) = <b>x</b>'<sub>i</sub><b>x</b><sub>j</sub>}}{\eqn{cov(X_i,X_j)=\textbf{x}_i'\textbf{x}_j}{cov(X_i,X_j) = x'_i x_j}}.

The distance
\ifelse{html}{\out{d(X<sub>i</sub>,X<sub>j</sub>)}}{\eqn{d(X_i,X_j)}{d(X_i,X_j)}}
between the variables expressed in terms of cross-products is

\ifelse{html}{\out{<center>d<sup>2</sup>(X<sub>i</sub>,X<sub>j</sub>) = <b>x</b>'<sub>i</sub><b>x</b><sub>i</sub> + <b>x</b>'<sub>j</sub><b>x</b><sub>j</sub> - 2<b>x</b>'<sub>i</sub><b>x</b><sub>j</sub></center>}}{\deqn{d^2(X_i,X_j) = \textbf{x}_i'\textbf{x}_i + \textbf{x}_j'\textbf{x}_j - 2\textbf{x}_i'\textbf{x}_j}{d^2(X_i,X_j) = x'_i x_i + x'_j x_j - 2x'_i x_j}}

Therefore, the output distance matrix will contain as off-diagonal entries
\ifelse{html}{\out{<center>d<sup>2</sup>(X<sub>i</sub>,X<sub>j</sub>) = var(X<sub>i</sub>) + var(X<sub>j</sub>) - 2cov(X<sub>i</sub>,X<sub>j</sub>)</center>}}{\deqn{d^2(X_i,X_j) = var(X_i)+var(X_j)- 2cov(X_i,X_j)}{d^2(X_i,X_j) = var(X_i) + var(X_j) - 2cov(X_i,X_j)}}

while in the diagonal, the distance between one variable with itself is
\ifelse{html}{\out{d<sup>2</sup>(X<sub>i</sub>,X<sub>i</sub>) = 0}}{\eqn{d^2(X_i,X_i)=0}{d^2(X_i,X_i) = 0}}
}
\examples{
set.seed(1234)
require(SFSI)
# Simulate matrix
n = 100; p=10
X = scale(matrix(rnorm(n*p),ncol=p))

# Distance matrix from a cross-product
COV = crossprod(X)   # Cross-product X'X
cov2dist(COV)
# it must equal (but faster) to:
as.matrix(dist(t(X)))^2

# Distance matrix from a variance-covariance matrix
COV = cov(X)   # Variance matrix of X
(n-1)*cov2dist(COV)
# it must equal (but faster) to:
as.matrix(dist(t(X)))^2

# Using void=TRUE
cov2dist(COV,void=TRUE)
(n-1)*COV   # notice that COV was modified
}
\author{
Marco Lopez-Cruz (\email{lopezcru@msu.edu}) and Gustavo de los Campos
}
