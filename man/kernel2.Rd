% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/R_utils_wC.R
\name{kernel2}
\alias{kernel2}
\title{kernel2 function}
\usage{
kernel2(XtX, kernel = NULL, void = FALSE)
}
\arguments{
\item{XtX}{Cross-product (\eqn{X'X}) of a matrix \eqn{X} with \eqn{p} (centered) variables.}

\item{kernel}{List consisting on one of:
\itemize{
  \item \code{list(kernel='GAUSSIAN',h)}. If \code{h} is not provided the value of \code{h=-2*log(0.5)} is used.
  \item \code{list(kernel='LAPLACIAN',h)}. If \code{h} is not provided the value of \code{h=-2*log(0.5)} is used.
  \item \code{list(kernel='POLYNOMIAL',a,b)}. The values of \code{a=1} and \code{b=2} are used when they are not provided.
}
Default \code{kernel=NULL} (no kernel)}

\item{void}{\code{TRUE} or \code{FALSE} to whether return or not return the output.
When \code{FALSE} no result is displayed but the input is modified. Default \code{void=FALSE}}
}
\value{
A squared matrix \eqn{K} containing the kernel transformation
}
\description{
Applies a kernel transformation to a covariance matrix among \eqn{p} predictors. The pairwise transformation
\eqn{K(x,y)} for vectors \eqn{x=(x_1,...,x_n)'} and \eqn{y=(y_1,...,y_n)'} is calculated from their cross-product,
\eqn{x'y = \sum{x_iy_i}}, as
\enumerate{
  \item Gaussian kernel. Bandwidth parameter \eqn{h}:
\deqn{K(x,y)=exp\{-h d^2(x,y)\}=exp\{-h [x'x + y'y - 2x'y]\}}
  \item Laplacian kernel. Bandwidth parameter \eqn{h}:
\deqn{K(x,y)=exp\{-h d(x,y)\}=exp\{-h \sqrt{x'x + y'y - 2x'y]}\}}
  \item Polynomial kernel. Parameters \eqn{a>0} and integer \eqn{b}:
\deqn{K(x,y)=[a(x'y) + 1]^b}
}
}
\examples{
set.seed(1234)
require(SFSI)
# Simulate matrix
n = 1000; p=10
X = scale(matrix(rnorm(n*p),ncol=p))
COV = cov(X)

# Gaussian kernel (h=0.2)
h = 0.2
kernel2(COV,kernel=list(kernel="GAUSSIAN",h=h))
# it must be equal (but faster) to:
exp(-h*as.matrix(dist(t(X)))^2/(n-1))  # or
exp(-h*cov2dist(COV))

# Laplacian kernel (h=0.2)
kernel2(COV,kernel=list(kernel="LAPLACIAN",h=h))
# it must be equal (but faster) to:
exp(-h*as.matrix(dist(t(X)))/sqrt(n-1))  # or
exp(-h*sqrt(cov2dist(COV)))

# Polynomial kernel (a=1.5, b=2)
a = 1.5; b = 2
kernel2(COV,kernel=list(kernel="POLYNOMIAL",a=a,b=b))
# it must be equal to:
(a*COV + 1)^b

# Using void=TRUE
kernel2(COV,kernel=list(kernel="POLYNOMIAL",a=a,b=b),void=TRUE)
COV   # notice that COV was modified
}
\author{
Marco Lopez-Cruz (\email{lopezcru@msu.edu}) and Gustavo de los Campos
}
