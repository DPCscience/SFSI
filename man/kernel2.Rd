% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/R_utils_wC.R
\name{kernel2}
\alias{kernel2}
\title{kernel2 function}
\usage{
kernel2(XtX, kernel = NULL, void = FALSE)
}
\arguments{
\item{XtX}{Symmetric numeric matrix (e.g., a variance-covariance matrix among \eqn{p}{p} variables)}

\item{kernel}{List consisting on one of:
\itemize{
  \item \code{list(kernel='GAUSSIAN',h)}. If \code{h} is not provided the value of \code{h=-2*log(0.5)} is used.
  \item \code{list(kernel='LAPLACIAN',h)}. If \code{h} is not provided the value of \code{h=-2*log(0.5)} is used.
  \item \code{list(kernel='POLYNOMIAL',a,b)}. The values of \code{a=1} and \code{b=2} are used when they are not provided.
}
Default \code{kernel=NULL} (no kernel)}

\item{void}{\code{TRUE} or \code{FALSE} to whether return or not return the output.
When \code{FALSE} no result is displayed but the input \code{XtX} is modified. Default \code{void=FALSE}}
}
\value{
A matrix \eqn{K}{K} containing the kernel transformation
}
\description{
Applies a kernel transformation to any symmetric matrix such as a variance matrix among \eqn{p} predictors
}
\details{
For any variables
\ifelse{html}{\out{X<sub>i</sub>}}{\eqn{X_i}{X_i}} and
\ifelse{html}{\out{X<sub>j</sub>}}{\eqn{X_j}{X_j}} with mean zero and with sample vectors
\ifelse{html}{\out{<b>x</b><sub>i</sub> = (x<sub>i1</sub>,...,x<sub>in</sub>)'}}{\eqn{\textbf{x}_i=(x_{i1},...,x_{in})'}{x_i=(x_i1,...,x_in)'}} and
\ifelse{html}{\out{<b>x</b><sub>j</sub> = (x<sub>j1</sub>,...,x<sub>jn</sub>)'}}{\eqn{\textbf{x}_j=(x_{j1},...,x_{jn})'}{x_j=(x_j1,...,x_jn)'}}
, their (sample) variances are equal (up-to a constant) to their cross-products, this is,
\ifelse{html}{\out{var(X<sub>i</sub>) = <b>x</b>'<sub>i</sub><b>x</b><sub>i</sub>}}{\eqn{var(X_i)=\textbf{x}_i'\textbf{x}_i}{var(X_i) = x'_i x_i}} and
\ifelse{html}{\out{var(X<sub>j</sub>) = <b>x</b>'<sub>j</sub><b>x</b><sub>j</sub>}}{\eqn{var(X_j)=\textbf{x}_j'\textbf{x}_j}{var(X_j) = x'_j x_j}}.
Likewise, the covariance is
\ifelse{html}{\out{cov(X<sub>i</sub>,X<sub>j</sub>) = <b>x</b>'<sub>i</sub><b>x</b><sub>j</sub>}}{\eqn{cov(X_i,X_j)=\textbf{x}_i'\textbf{x}_j}{cov(X_i,X_j) = x'_i x_j}}.

The output matrix will contain the pairwise transformation
\ifelse{html}{\out{K(X<sub>i</sub>,X<sub>j</sub>)}}{\eqn{K(X_i,X_j)}{K(X_i,X_j)}}
given by

\enumerate{
  \item Gaussian kernel (bandwidth parameter \eqn{h}{h}):

  \ifelse{html}{\out{<center>K(X<sub>i</sub>,X<sub>j</sub>) = exp{-h d<sup>2</sup>(X<sub>i</sub>,X<sub>j</sub>)} = exp{-h [var(X<sub>i</sub>) + var(X<sub>j</sub>) - 2cov(X<sub>i</sub>,X<sub>j</sub>)]}</center>}}{\deqn{K(X_i,X_j)=exp\{-h\;d^2(X_i,X_j)\}=exp\{-h [var(X_i)+var(X_j)-2cov(X_i,X_j)]\}}{K(X_i,X_j) = exp(-h d^2(X_i,X_j)) = exp(-h (var(X_i) + var(X_j)- 2cov(X_i,X_j)))}}

  \item Laplacian kernel (bandwidth parameter \eqn{h}{h}):

  \ifelse{html}{\out{<center>K(X<sub>i</sub>,X<sub>j</sub>) = exp{-h d(X<sub>i</sub>,X<sub>j</sub>)} = exp{-h &radic;[var(X<sub>i</sub>) + var(X<sub>j</sub>) - 2cov(X<sub>i</sub>,X<sub>j</sub>)]}</center>}}{\deqn{K(X_i,X_j)=exp\{-h\;d(X_i,X_j)\}=exp\{-h \sqrt{var(X_i)+var(X_j)-2cov(X_i,X_j)}\}}{K(X_i,X_j) = exp(-h d(X_i,X_j)) = exp(-h sqrt(var(X_i) + var(X_j)- 2cov(X_i,X_j)))}}

  \item Polynomial kernel (parameters \eqn{a>0}{a>0} and integer \eqn{b}{b}):

  \ifelse{html}{\out{<center>K(X<sub>i</sub>,X<sub>j</sub>) = [a cov(X<sub>i</sub>,X<sub>j</sub>) + 1]<sup>b</sup></center>}}{\deqn{K(X_i,X_j)=[a\;cov(X_i,X_j)+1]^b}{K(X_i,X_j) = (a cov(X_i,X_j) + 1)^b}}
}
}
\examples{
set.seed(1234)
require(SFSI)
# Simulate matrix
n = 1000; p=10
X = scale(matrix(rnorm(n*p),ncol=p))
COV = cov(X)

# Gaussian kernel (h=0.2)
h = 0.2
kernel2(COV,kernel=list(kernel="GAUSSIAN",h=h))
# it must be equal (but faster) to:
exp(-h*as.matrix(dist(t(X)))^2/(n-1))  # or
exp(-h*cov2dist(COV))

# Laplacian kernel (h=0.2)
kernel2(COV,kernel=list(kernel="LAPLACIAN",h=h))
# it must be equal (but faster) to:
exp(-h*as.matrix(dist(t(X)))/sqrt(n-1))  # or
exp(-h*sqrt(cov2dist(COV)))

# Polynomial kernel (a=1.5, b=2)
a = 1.5; b = 2
kernel2(COV,kernel=list(kernel="POLYNOMIAL",a=a,b=b))
# it must be equal to:
(a*COV + 1)^b

# Using void=TRUE
kernel2(COV,kernel=list(kernel="POLYNOMIAL",a=a,b=b),void=TRUE)
COV   # notice that COV was modified
}
\author{
Marco Lopez-Cruz (\email{lopezcru@msu.edu}) and Gustavo de los Campos
}
